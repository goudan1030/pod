# Teemdrop 3D模型渲染流程深度分析

## 📋 概述

本文档深入分析 Teemdrop 网站从 3D 模型加载、拆解、用户上传贴图到最终渲染的完整技术流程。

---

## 🔍 核心技术栈确认

### 1. 3D 渲染引擎
- **Three.js** (通过 `__THREE__` 全局对象确认)
- **WebGL2** (Canvas 使用 WebGL2 上下文)
- **Canvas 尺寸**: 3080 x 2326 像素

### 2. 模型文件格式
- **自定义格式**: `.pda` 文件 (Teemdrop Design Archive)
- **存储位置**: `cdn.Teemdrop.com/static/blender/{uuid}.pda`
- **来源**: 从 Blender 导出，包含几何体、UV、材质信息

### 3. 纹理系统
- **格式**: JPG/PNG
- **存储**: `cdn.Teemdrop.com/texture/{uuid}.jpg`
- **支持**: 多纹理层级、用户自定义贴图

### 4. 环境光照
- **HDR 贴图**: `cdn.Teemdrop.com/hdr/{uuid}.hdr`
- **用途**: 环境反射、真实光照效果

---

## 🎯 完整流程拆解

### 阶段一：模型数据获取与准备

#### 1.1 API 调用序列

```
用户访问页面
  ↓
GET /api/v2/models/details?mockupNameKey=short-sleeved-shirt-mockup-605371
  ↓ (返回模型元数据)
GET /api/v2/models/preview?id=5806&blankSettingId=30425
  ↓ (返回预览配置)
GET /api/v2/materials/science?pageSize=1000&scienceType=1
  ↓ (获取科学材质库)
GET /api/v2/material_effect
  ↓ (获取材质效果配置)
```

#### 1.2 模型详情数据结构推测

根据 API 调用，模型详情可能包含：

```javascript
{
  modelId: 5806,
  modelName: "short-sleeved-shirt-mockup-605371",
  blenderFileUrl: "cdn.Teemdrop.com/static/blender/{uuid}.pda",
  parts: [
    {
      partId: "front",
      partName: "正面",
      uvRegion: {...},
      textureSlot: "map_diffuse"
    },
    {
      partId: "back",
      partName: "背面",
      uvRegion: {...}
    },
    {
      partId: "sleeve",
      partName: "袖子",
      uvRegion: {...}
    },
    {
      partId: "collar",
      partName: "领口",
      uvRegion: {...}
    }
  ],
  defaultMaterials: [...],
  hdrEnvironment: "cdn.Teemdrop.com/hdr/{uuid}.hdr"
}
```

#### 1.3 模型文件加载

**关键发现**:
- 模型文件 `.pda` 通过 `fetch` API 加载
- 文件大小: 通常较大 (需压缩传输)
- 加载时间: ~5.5秒 (首次加载)

**加载流程**:
```javascript
// 推测的实现方式
async function loadModel(modelUrl) {
  const response = await fetch(modelUrl);
  const arrayBuffer = await response.arrayBuffer();
  
  // .pda 格式可能是:
  // 1. 压缩的 GLB/glTF 格式
  // 2. 自定义二进制格式
  // 3. 包含额外元数据的 Blender 导出格式
  
  const modelData = parsePDAData(arrayBuffer);
  return modelData;
}
```

---

### 阶段二：模型拆解 (Parts System)

#### 2.1 模型部分 (Parts) 概念

**UI 显示**: "Custom part: 4 Parts"

这表明模型被拆分为 4 个可编辑部分:
1. **正面** (Front)
2. **背面** (Back)
3. **袖子** (Sleeves)
4. **领口** (Collar)

#### 2.2 技术实现原理

##### 方法一：Submesh 分离 (最可能)

```javascript
// Three.js 中的实现
const model = await loadModel('model.pda');

// 每个部分对应一个独立的 Mesh 对象
const frontMesh = model.scene.getObjectByName('front');
const backMesh = model.scene.getObjectByName('back');
const sleeveMesh = model.scene.getObjectByName('sleeve');
const collarMesh = model.scene.getObjectByName('collar');

// 每个 Mesh 有独立的材质和纹理槽位
frontMesh.material = new THREE.MeshStandardMaterial({
  map: null, // 等待用户上传
  roughness: 0.7,
  metalness: 0.1
});
```

##### 方法二：UV Mask 分离

```javascript
// 使用 UV 坐标定义不同区域
const uvMask = {
  front: { u: [0, 0.5], v: [0, 0.5] },
  back: { u: [0.5, 1], v: [0, 0.5] },
  sleeve: { u: [0, 0.25], v: [0.5, 1] },
  collar: { u: [0.75, 1], v: [0.5, 1] }
};

// 在 shader 中根据 UV 坐标判断应用哪个贴图
```

##### 方法三：材质 ID 分离 (推荐)

```javascript
// 每个部分有独立的材质索引
const materialMap = {
  0: { name: 'front', baseColor: '#ffffff' },
  1: { name: 'back', baseColor: '#ffffff' },
  2: { name: 'sleeve', baseColor: '#ffffff' },
  3: { name: 'collar', baseColor: '#ffffff' }
};

// 通过材质索引切换贴图
function applyTextureToPart(partIndex, textureUrl) {
  const material = materials[partIndex];
  material.map = textureLoader.load(textureUrl);
}
```

---

### 阶段三：用户上传贴图

#### 3.1 上传界面

**UI 元素**:
- "Upload images" 按钮
- 尺寸提示: "317 x 448 px" (推荐尺寸)
- 格式支持: "JPG, PNG, SVG"

#### 3.2 上传流程

```javascript
// 1. 用户选择文件
const fileInput = document.querySelector('input[type="file"]');
const file = fileInput.files[0];

// 2. 文件验证
if (!validateFile(file)) {
  // 检查格式、尺寸、大小
  return;
}

// 3. 图片预处理 (推测)
const processedImage = await preprocessImage(file);
// - 调整尺寸到推荐大小
// - 压缩优化
// - 转换为 WebP 或优化格式

// 4. 上传到服务器
const formData = new FormData();
formData.append('image', processedImage);
formData.append('modelId', currentModelId);
formData.append('partId', selectedPartId);

const response = await fetch('/api/v2/upload/texture', {
  method: 'POST',
  body: formData
});

// 5. 获取存储 URL
const { textureUrl } = await response.json();
// 返回: "cdn.Teemdrop.com/texture/{uuid}.jpg"
```

#### 3.3 服务器端处理

**可能的上传端点**:
```
POST /api/v2/upload/texture
  - 文件验证
  - 图片优化和压缩
  - 存储到 AWS S3
  - 生成 CDN URL
  - 返回纹理 ID 和 URL
```

**存储结构**:
```
cdn.Teemdrop.com/texture/
  {uploadId}_{materialId}.jpg  // 用户上传的贴图
  {materialId}_{blankId}.jpg   // 默认/空白材质
```

---

### 阶段四：贴图渲染流程

#### 4.1 Three.js 纹理加载

```javascript
// 纹理加载器
const textureLoader = new THREE.TextureLoader();

// 加载用户上传的贴图
const userTexture = textureLoader.load(
  'cdn.Teemdrop.com/texture/{uuid}.jpg',
  (texture) => {
    // 纹理加载完成回调
    texture.flipY = false; // 根据 UV 设置
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    
    // 应用纹理到指定部分
    applyTextureToPart(selectedPart, texture);
  },
  undefined,
  (error) => {
    console.error('纹理加载失败', error);
  }
);
```

#### 4.2 材质更新

```javascript
// 创建或更新材质
function createMaterialWithTexture(baseMaterial, userTexture) {
  return new THREE.MeshStandardMaterial({
    map: userTexture,              // 用户贴图 (Albedo/Diffuse)
    normalMap: baseMaterial.normal, // 法线贴图 (保持布料纹理)
    roughnessMap: baseMaterial.roughness,
    metalnessMap: baseMaterial.metalness,
    roughness: 0.7,                // 布料较粗糙
    metalness: 0.1,                // 布料非金属
    envMap: hdrEnvironment,        // 环境贴图
    envMapIntensity: 1.0
  });
}

// 应用到指定部分
function applyTextureToPart(partName, texture) {
  const mesh = scene.getObjectByName(partName);
  const newMaterial = createMaterialWithTexture(
    mesh.material,
    texture
  );
  mesh.material = newMaterial;
  
  // 标记材质已更新
  mesh.material.needsUpdate = true;
}
```

#### 4.3 多纹理混合 (高级)

如果系统支持基础布料纹理 + 用户图案叠加:

```javascript
// 自定义 Shader 实现混合
const customShader = {
  uniforms: {
    baseTexture: { value: baseClothTexture },
    userTexture: { value: userPatternTexture },
    maskTexture: { value: maskTexture }, // 控制混合区域
    blendFactor: { value: 1.0 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D baseTexture;
    uniform sampler2D userTexture;
    uniform sampler2D maskTexture;
    uniform float blendFactor;
    
    varying vec2 vUv;
    
    void main() {
      vec4 base = texture2D(baseTexture, vUv);
      vec4 user = texture2D(userTexture, vUv);
      vec4 mask = texture2D(maskTexture, vUv);
      
      // 根据 mask 混合两个纹理
      vec4 finalColor = mix(base, user, mask.r * blendFactor);
      gl_FragColor = finalColor;
    }
  `
};

const customMaterial = new THREE.ShaderMaterial(customShader);
```

---

### 阶段五：实时渲染

#### 5.1 场景设置

```javascript
// 创建场景
const scene = new THREE.Scene();
scene.background = null; // 透明背景

// 加载 HDR 环境贴图
const hdrLoader = new THREE.RGBELoader();
hdrLoader.load('cdn.Teemdrop.com/hdr/{uuid}.hdr', (texture) => {
  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  const envMap = pmremGenerator.fromEquirectangular(texture).texture;
  scene.environment = envMap; // 设置环境光照
  pmremGenerator.dispose();
});

// 添加灯光 (可能同时使用环境光和方向光)
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(5, 10, 7);
scene.add(directionalLight);
```

#### 5.2 渲染循环

```javascript
// 创建渲染器
const renderer = new THREE.WebGLRenderer({
  canvas: canvasElement,
  antialias: true,
  alpha: true // 透明背景
});
renderer.setSize(3080, 2326);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;

// 创建摄像机
const camera = new THREE.PerspectiveCamera(
  45, // FOV
  width / height, // Aspect
  0.1, // Near
  1000 // Far
);
camera.position.set(0, 0, 5);

// 渲染循环
function animate() {
  requestAnimationFrame(animate);
  
  // 用户交互: 旋转、缩放、平移
  controls.update(); // OrbitControls 或类似控件
  
  // 渲染场景
  renderer.render(scene, camera);
}
animate();
```

#### 5.3 交互控制

```javascript
// 使用 OrbitControls 实现模型旋转、缩放
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.minDistance = 2;
controls.maxDistance = 10;
controls.autoRotate = false; // 可能支持自动旋转
```

---

### 阶段六：导出和优化

#### 6.1 高分辨率渲染

```javascript
// 导出时使用更高分辨率
function renderHighResolution(width, height) {
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = width;
  tempCanvas.height = height;
  
  const tempRenderer = new THREE.WebGLRenderer({
    canvas: tempCanvas,
    antialias: true
  });
  
  // 临时调整摄像机视角
  const originalSize = renderer.getSize(new THREE.Vector2());
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  
  // 渲染
  tempRenderer.render(scene, camera);
  
  // 导出为图片
  const imageData = tempCanvas.toDataURL('image/png');
  
  // 恢复原始设置
  renderer.setSize(originalSize.x, originalSize.y);
  camera.aspect = originalSize.x / originalSize.y;
  camera.updateProjectionMatrix();
  
  return imageData;
}
```

#### 6.2 切割线导出

**API 调用**: `GET /api/v2/project/knife?id=5806&bleed=5&export_type=model`

这可能返回:
- SVG 切割线路径
- PDF 切割指南
- DXF 文件 (用于生产)

---

## 🔧 关键技术细节

### 1. .pda 文件格式推测

`.pda` 文件可能是以下格式之一:

**可能性 1: 压缩的 GLB**
```javascript
// 使用 gzip 或 lz4 压缩的 GLB 文件
async function loadPDA(url) {
  const compressed = await fetch(url).then(r => r.arrayBuffer());
  const decompressed = decompress(compressed); // 解压
  const gltf = parseGLB(decompressed);
  return gltf;
}
```

**可能性 2: 自定义二进制格式**
```
PDA 文件结构 (推测):
[Header] (32 bytes)
  - Magic: "PDA" (3 bytes)
  - Version: uint8
  - Geometry offset: uint32
  - Texture offset: uint32
  - Material offset: uint32
  
[Geometry Data]
  - Vertices (float32 array)
  - Normals (float32 array)
  - UVs (float32 array)
  - Indices (uint16/uint32 array)
  - Part IDs (uint8 array)
  
[Texture References]
  - Texture count: uint16
  - Texture entries: [uuid, slot, ...]
  
[Material Data]
  - Material count: uint16
  - Material definitions: [...]
```

**可能性 3: JSON + Binary**
```json
{
  "metadata": {
    "version": "1.0",
    "modelId": "ec5128a0-f52a-4815-a716-a59af5ae23fd"
  },
  "geometry": "base64_encoded_binary",
  "parts": [
    {
      "name": "front",
      "materialId": 0,
      "vertexRange": [0, 1000]
    }
  ],
  "materials": [...],
  "textures": [...]
}
```

### 2. 材质系统

#### 2.1 科学材质库

**API**: `GET /api/v2/materials/science?pageSize=1000&scienceType=1`

可能返回材质预设:
```json
{
  "materials": [
    {
      "id": "cotton_white",
      "name": "Cotton - White",
      "type": "science",
      "properties": {
        "roughness": 0.7,
        "metalness": 0.0,
        "normalMap": "cdn.Teemdrop.com/texture/cotton_normal.jpg",
        "aoMap": "cdn.Teemdrop.com/texture/cotton_ao.jpg"
      }
    },
    {
      "id": "polyester_black",
      "name": "Polyester - Black",
      "properties": {...}
    }
  ]
}
```

#### 2.2 材质效果

**API**: `GET /api/v2/material_effect`

可能包含材质后处理效果配置。

### 3. UV 映射和贴图坐标

```javascript
// UV 偏移和缩放
function adjustTextureTransform(partName, transform) {
  const mesh = scene.getObjectByName(partName);
  const material = mesh.material;
  
  if (material.map) {
    // 偏移
    material.map.offset.x = transform.offsetX || 0;
    material.map.offset.y = transform.offsetY || 0;
    
    // 重复/缩放
    material.map.repeat.x = transform.repeatX || 1;
    material.map.repeat.y = transform.repeatY || 1;
    
    // 旋转 (需要额外的旋转矩阵)
    material.map.center.set(0.5, 0.5);
    material.map.rotation = transform.rotation || 0;
  }
}
```

---

## 🚀 性能优化策略

### 1. 延迟加载

```javascript
// 按需加载纹理
const textureCache = new Map();

async function loadTextureWhenNeeded(partName, textureUrl) {
  if (textureCache.has(textureUrl)) {
    return textureCache.get(textureUrl);
  }
  
  const texture = await textureLoader.loadAsync(textureUrl);
  textureCache.set(textureUrl, texture);
  return texture;
}
```

### 2. 纹理压缩

```javascript
// 使用压缩纹理格式 (如果浏览器支持)
const compressedTexture = renderer.getExtension('WEBGL_compressed_texture_s3tc');
if (compressedTexture) {
  // 使用 DXT/BC 压缩纹理
  texture.format = THREE.RGB_S3TC_DXT1_Format;
}
```

### 3. LOD (细节层次)

```javascript
// 根据相机距离切换模型精度
function updateLOD() {
  const distance = camera.position.distanceTo(model.position);
  
  if (distance > 10) {
    // 使用低精度模型
    switchModel(modelLOD.low);
  } else if (distance > 5) {
    // 使用中精度模型
    switchModel(modelLOD.medium);
  } else {
    // 使用高精度模型
    switchModel(modelLOD.high);
  }
}
```

---

## 📊 数据流图

```
┌─────────────────┐
│   用户访问页面   │
└────────┬────────┘
         │
         ▼
┌─────────────────────────┐
│ GET /api/v2/models/     │
│    details             │
│ (获取模型元数据)         │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ GET /api/v2/models/     │
│    preview             │
│ (获取预览配置)          │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ GET .pda 模型文件       │
│ (加载几何体和UV)        │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ Three.js 解析模型       │
│ - 创建 Scene           │
│ - 加载 Mesh            │
│ - 设置初始材质          │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ 用户上传贴图            │
│ POST /api/v2/upload/    │
│    texture             │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ 服务器处理              │
│ - 验证文件             │
│ - 压缩优化             │
│ - 存储到 S3            │
│ - 返回 CDN URL         │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ 前端加载纹理            │
│ TextureLoader.load()   │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ 应用纹理到指定部分      │
│ material.map = texture │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ 实时渲染                │
│ renderer.render()      │
│ - 环境光照             │
│ - PBR 材质             │
│ - 用户贴图             │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ 用户交互                │
│ - 旋转/缩放            │
│ - 切换部分             │
│ - 调整纹理             │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ 导出高分辨率图像        │
│ renderHighResolution() │
└─────────────────────────┘
```

---

## 🎯 关键技术突破点

### 1. 模型拆解实现

**挑战**: 如何将单一 3D 模型拆分为多个可独立编辑的部分?

**解决方案**:
- ✅ 使用命名约定: 每个部分有独立的 Object3D 名称
- ✅ 材质索引映射: 通过材质 ID 关联部分
- ✅ UV 区域划分: 在 UV 空间中定义区域边界

### 2. 动态纹理替换

**挑战**: 如何在运行时动态替换纹理而不影响性能?

**解决方案**:
- ✅ 纹理对象复用: 只更新 texture 对象，不重建材质
- ✅ 异步加载: 使用 Promise 和回调处理加载
- ✅ 纹理池: 缓存常用纹理，减少重复加载

### 3. 实时预览性能

**挑战**: 如何在高分辨率下保持流畅的交互?

**解决方案**:
- ✅ 自适应分辨率: 交互时降低分辨率，静止时提高
- ✅ 帧率控制: 限制最大帧率，节省 GPU 资源
- ✅ 资源管理: 及时释放不用的纹理和几何体

---

## 📝 总结

### 核心技术点

1. **模型格式**: 自定义 `.pda` 格式，可能基于 GLB/glTF
2. **模型拆解**: 通过 Submesh 或材质索引实现多部分编辑
3. **纹理系统**: 支持用户上传、多层级混合、动态替换
4. **渲染引擎**: Three.js + WebGL2，支持 PBR 材质
5. **环境光照**: HDR 环境贴图实现真实光照效果
6. **性能优化**: 延迟加载、纹理缓存、LOD 等技术

### 实现难点

1. ✅ **模型解析**: .pda 格式的自定义解析器
2. ✅ **纹理混合**: 基础材质 + 用户贴图的混合算法
3. ✅ **实时性能**: 高分辨率下的流畅交互
4. ✅ **资源管理**: 大量纹理和模型的高效加载与释放

---

*分析日期: 2026-01-15*
*分析工具: Playwright + 浏览器开发者工具 + 网络抓包*
