# UV 边界提取算法详解

## 1. 核心原理

在三维计算机图形学中，**UV 映射**是将 2D 图像投影到 3D 模型表面的过程。每个 3D 模型的顶点除了有空间坐标 $(x, y, z)$ 外，通常还包含纹理坐标 $(u, v)$。

**UV 边界提取**的目标是从这些离散的三角形网格数据中，找出这一组 UV 构成的 2D 形状的**外轮廓**。这在 3D 打印、纹理编辑、以及生成 2D 裁片图时非常关键。

核心逻辑基于拓扑学的一个简单事实：
> **在一个封闭或开放的网格表面中，内部的边会被两个三角形共用，而边界上的边只被一个三角形使用。**

## 2. 算法流程图

```mermaid
graph TD
    A[开始: 输入模型的 UV 坐标数组] --> B[遍历所有三角形]
    B --> C{处理每个三角形的 3 条边}
    C --> D[生成边的唯一 Key (Hash)]
    D --> E[统计每条边出现的次数]
    E --> F[筛选计数为 1 的边]
    F --> G[得到无序边界线段集合]
    G --> H[线段缝合: 构建邻接表]
    H --> I[贪心搜索: 连接成闭合路径]
    I --> J[输出: 有序的 2D 形状路径 (SVG Path)]
```

## 3. 详细步骤解析

### 第一步：边的统计 (Edge Counting)

我们遍历网格的所有三角形。对于每个三角形的 3 条边 $(v_1, v_2), (v_2, v_3), (v_3, v_1)$，我们记录它们出现的次数。

为了识别同一条边（无论方向是 $A \to B$ 还是 $B \to A$），我们需要一个标准化的 Key 生成规则：
- 对端点坐标进行一定的精度处理（防止浮点数误差）。
- 始终让较小的坐标在前，较大的在后，例如：`key = min(p1, p2) + "|" + max(p1, p2)`。

**代码逻辑示例**：
```typescript
const edgeCounts = new Map<string, number>();

// 遍历所有三角形
for (let i = 0; i < uvs.length; i += 6) { // 假设每 6 个 float 代表一个三角形 (3个点 * 2坐标)
    const p1 = { u: uvs[i], v: uvs[i+1] };
    const p2 = { u: uvs[i+2], v: uvs[i+3] };
    const p3 = { u: uvs[i+4], v: uvs[i+5] };

    [ [p1, p2], [p2, p3], [p3, p1] ].forEach(([start, end]) => {
        const key = generateEdgeKey(start, end);
        edgeCounts.set(key, (edgeCounts.get(key) || 0) + 1);
    });
}
```

### 第二步：提取边界边 (Boundary Filter)

遍历 `edgeCounts` Map，找出所有**计数为 1** 的边。这些边就是 UV 岛的边缘。

**结果**：此时我们得到了一堆散乱的线段集合，例如：
- 线段 A: $(0.1, 0.1) \to (0.5, 0.1)$
- 线段 B: $(0.5, 0.5) \to (0.1, 0.5)$
- 线段 C: $(0.5, 0.1) \to (0.5, 0.5)$
- ...

### 第三步：线段缝合 (Path Reconstruction)

散乱的线段无法直接用于 SVG 绘图（`M...L...L...Z`），我们需要将它们首尾相连。

1.  **构建邻接表 (Adjacency List)**：
    创建一个 Map，将每个**顶点**映射到与它相连的**顶点列表**。
    - Key: 顶点坐标字符串 `"u,v"`
    - Value: 相邻顶点坐标列表 `["u2,v2", ...]`

2.  **贪心搜索 (Greedy Walk)**：
    - 任选一个未访问的线段起点作为当前点。
    - 将其加入路径 (`Move To`)。
    - 在邻接表中查找当前点的邻居。
    - 移动到邻居点 (`Line To`)，并从邻接表中删除这条连接（防止回头）。
    - 重复直到无法找到邻居（路径闭合）。
    - 如果还有未访问的线段，重复上述步骤（处理多个不连通的 UV 岛）。

## 4. 关键难点与优化

### 4.1 浮点数精度问题 (Floating Point Precision)
UV 坐标通常是 32 位浮点数。由于计算误差，两个理论上重合的点可能由微小的差异（例如 `0.10000001` vs `0.09999999`）。
**解决方案**：引入一个精度因子（Epsilon），或者在生成 Key 时先乘以一个大数（如 10000）取整。
```typescript
const PRECISION = 10000;
const hash = (n: number) => Math.round(n * PRECISION);
```

### 4.2 T型接点与非流形结构 (Non-Manifold Geometry)
如果模型质量较差，可能存在非流形边（一条边被 3 个或更多三角形共用），或者顶点重叠但未焊接。
**解决方案**：虽然上述算法能处理大部分标准网格，但在处理“脏”模型时，可能需要预处理步骤（如焊接顶点 `Merge Vertices`）来确保拓扑结构的正确性。

### 4.3 多个 UV 岛 (Multi-Islands)
一个模型通常包含多个独立的部件（如衣服的前片、后片、袖子）。
**解决方案**：算法天然支持多岛提取。在“线段缝合”阶段，外层循环会确保所有独立的闭合环路都被提取出来。

## 5. 应用场景

1.  **2D 裁片生成**：将 3D 服装模型的 UV 展开图直接转换为生产用的裁片轮廓。
2.  **纹理绘画界限**：在 3D 绘图软件中，限制画笔只在特定 UV 区域内生效。
3.  **贴纸定位**：用户在 2D 视图中拖拽贴纸时，利用边界判断贴纸是否超出了模型范围。

---
*本文档基于 [Teemdrop 3D Designer](file:///Users/mac/POD/pod) 项目技术实现整理。*
