# Pacdora 形状来源分析报告

## 🎯 问题
用户询问：界面上的这些形状（T恤轮廓、袖子、领口等）是**自动生成的SVG**，还是**提前上传的**？

---

## 🔍 分析结果

### 结论：**提前定义 + 自动生成**

这些形状是**预先定义在模型数据中**，然后**前端自动生成SVG/Canvas绘制**的。

---

## 📊 证据分析

### 1. 网络请求分析

**未发现独立的形状文件**:
- ❌ 没有找到专门的 `.svg` 形状文件
- ❌ 没有找到形状相关的 API 调用（如 `/api/v2/shapes` 或 `/api/v2/outlines`）
- ✅ 只找到了模型预览 API: `/api/v2/models/preview`

**发现的资源**:
- ✅ 模型文件: `cdn.pacdora.com/static/blender/{uuid}.pda`
- ✅ 模型预览数据: `/api/v2/models/preview?id=5806`
- ✅ 切割线导出: `/api/v2/project/knife?id=5806&bleed=5&export_type=model`

### 2. 页面元素分析

**发现的SVG路径**:
```javascript
// 多个重复的路径，可能是不同部分的轮廓
"M6.304,125.9636  L6.304,45.3539  L7.5034,44.7189..."
// 这个路径出现了8次，对应8个不同的部分
```

**Canvas元素**:
- 主Canvas: 3080 x 2326 (3D渲染)
- 辅助Canvas: 560 x 560 (可能用于2D形状绘制)

### 3. 模型预览API数据结构

从 `/api/v2/models/preview` 返回的数据包含:
```json
{
  "data": {
    "layer": {
      "traditional": {
        "bleedline": 5,
        "line_guides": null,  // 可能包含轮廓线数据
        ...
      }
    }
  }
}
```

### 4. UI功能分析

**关键按钮**: "Export dieline" (导出切割线)
- 这个按钮的存在说明：
  1. 系统知道每个模型的切割线/轮廓
  2. 这些轮廓是模型的一部分，不是用户上传的
  3. 可以从模型数据中提取并导出

---

## 🔧 技术实现推测

### 方案一：从3D模型UV展开自动生成（最可能）

```javascript
// 1. 加载3D模型
const model = await loadModel('model.pda');

// 2. 提取UV坐标
const uvCoordinates = extractUVCoordinates(model);

// 3. 根据UV坐标生成2D轮廓
const outlines = generateOutlinesFromUV(uvCoordinates);

// 4. 绘制到Canvas或生成SVG
const svgPaths = convertToSVGPaths(outlines);
```

**优势**:
- ✅ 形状与3D模型完全对应
- ✅ 不需要单独存储形状数据
- ✅ 自动适配不同模型

### 方案二：模型数据中预定义轮廓

```javascript
// .pda 文件可能包含：
{
  geometry: {...},
  materials: {...},
  outlines: {  // 预定义的轮廓数据
    front: {
      path: "M6.304,125.9636 L6.304,45.3539...",
      uvBounds: {...}
    },
    back: {...},
    sleeve: {...}
  }
}
```

**优势**:
- ✅ 轮廓精确，由设计师在Blender中定义
- ✅ 可以包含额外的元数据（如出血线）
- ✅ 性能好，不需要实时计算

### 方案三：后端API返回轮廓数据

```javascript
// API可能返回：
GET /api/v2/models/preview?id=5806
{
  "data": {
    "outlines": {
      "front": {
        "svg": "<path d='M6.304,125.9636...'/>",
        "bounds": {...}
      },
      ...
    }
  }
}
```

---

## 🎨 前端渲染方式

### 方式一：SVG路径绘制（当前使用）

```javascript
// 从模型数据或API获取路径
const outlinePaths = modelData.outlines;

// 创建SVG元素
const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
outlinePaths.forEach(pathData => {
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', pathData.path);
  path.setAttribute('stroke', '#ccc');
  path.setAttribute('fill', 'white');
  svg.appendChild(path);
});
```

### 方式二：Canvas 2D绘制

```javascript
// 使用Canvas绘制轮廓
const canvas = document.querySelector('canvas');
const ctx = canvas.getContext('2d');

outlinePaths.forEach(pathData => {
  const path = new Path2D(pathData.path);
  ctx.strokeStyle = '#ccc';
  ctx.fillStyle = 'white';
  ctx.fill(path);
  ctx.stroke(path);
});
```

### 方式三：WebGL绘制（用于3D预览）

```javascript
// 3D预览使用WebGL
// 2D编辑界面可能使用Canvas 2D或SVG
```

---

## 📝 完整流程推测

```
1. 设计师在Blender中创建3D模型
   ↓
2. 在Blender中定义UV展开和轮廓线
   ↓
3. 导出为.pda格式（包含几何体、UV、轮廓数据）
   ↓
4. 上传到服务器，存储到CDN
   ↓
5. 用户访问页面
   ↓
6. 前端加载模型预览API
   ↓
7. 从API数据或模型文件中提取轮廓数据
   ↓
8. 前端自动生成SVG路径或Canvas绘制
   ↓
9. 渲染到2D编辑界面
```

---

## ✅ 最终结论

### 这些形状是：

1. **预先定义** ✅
   - 在Blender建模时定义
   - 存储在模型文件或API数据中
   - 每个模型都有固定的轮廓模板

2. **自动生成** ✅
   - 前端从模型数据中提取
   - 自动转换为SVG路径或Canvas绘制
   - 不需要用户上传

3. **不是用户上传的** ❌
   - 用户上传的是**贴图/图案**
   - 不是形状轮廓本身
   - 形状是模型模板的一部分

### 类比理解：

- **形状轮廓** = 画布的框架（固定，由平台提供）
- **用户上传的图片** = 画布上的内容（可变，由用户上传）

---

## 🔍 验证方法

如果要进一步确认，可以：

1. **检查模型文件**: 下载 `.pda` 文件，查看是否包含轮廓数据
2. **拦截API响应**: 查看 `/api/v2/models/preview` 的完整响应
3. **检查前端代码**: 查找 `pacdora-editor` 或 `Dieline` 相关的代码
4. **查看网络请求**: 确认是否有形状相关的API调用

---

*分析日期: 2026-01-15*
*分析方法: 网络抓包 + DOM分析 + API响应分析*
